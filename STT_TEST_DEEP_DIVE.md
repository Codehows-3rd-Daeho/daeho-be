# STT 패키지 테스트 딥다이브

> STT(Speech-to-Text) 패키지의 성능 및 안정성 테스트에 대한 상세 문서
>
> **테스트 범위**: 분산락, Kafka, E2E, 클러스터 HA, k6 성능 테스트

---

## 목차

1. [테스트 아키텍처 개요](#1-테스트-아키텍처-개요)
2. [테스트별 상세 분석](#2-테스트별-상세-분석)
3. [사용 기술 딥다이브](#3-사용-기술-딥다이브)
4. [성능 지표 및 임계값](#4-성능-지표-및-임계값)
5. [커버하지 못한 시나리오](#5-커버하지-못한-시나리오)
6. [추천 테스트 전략](#6-추천-테스트-전략)

---

## 1. 테스트 아키텍처 개요

### 1.1 STT 처리 파이프라인

```
┌──────────────┐     ┌──────────────┐     ┌──────────────┐     ┌──────────────┐
│   RECORDING  │────▶│   ENCODING   │────▶│  PROCESSING  │────▶│  SUMMARIZING │
│              │     │              │     │              │     │              │
│ - 청크 수집   │     │ - WAV 인코딩  │     │ - Daglo STT  │     │ - Daglo NLP  │
│ - Heartbeat  │     │ - 파일 준비   │     │ - 텍스트 변환 │     │ - 요약 생성   │
└──────────────┘     └──────────────┘     └──────────────┘     └──────────────┘
       │                    │                    │                    │
       ▼                    ▼                    ▼                    ▼
┌──────────────────────────────────────────────────────────────────────────────┐
│                              Redis (캐싱 + 분산락)                              │
│  - stt:status:{id} : 상태 캐싱 (30분 TTL)                                      │
│  - stt:recording:heartbeat:{id} : 비정상 종료 감지 (30초 TTL)                   │
│  - stt:processor:lock:* : 분산락 (5초 TTL)                                     │
└──────────────────────────────────────────────────────────────────────────────┘
       │                    │                    │                    │
       ▼                    ▼                    ▼                    ▼
┌──────────────────────────────────────────────────────────────────────────────┐
│                              Kafka (이벤트 브로커)                              │
│  - stt-encoding-topic : 인코딩 작업                                           │
│  - stt-processing-topic : STT 변환 작업 (RetryableTopic)                      │
│  - stt-summarizing-topic : 요약 작업 (RetryableTopic)                         │
└──────────────────────────────────────────────────────────────────────────────┘
```

### 1.2 테스트 계층 구조

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                           k6 성능 테스트 (외부)                               │
│  - stt-load-test.js : REST API 부하                                         │
│  - stt-websocket-test.js : WebSocket STOMP 부하                             │
├─────────────────────────────────────────────────────────────────────────────┤
│                      Testcontainers 통합 테스트 (실제 컨테이너)                 │
│  - DistributedLockIntegrationTest : Redis 분산락                            │
│  - SttKafkaIntegrationTest : Kafka 메시징                                   │
│  - SttE2EIntegrationTest : 전체 플로우                                       │
│  - KafkaClusterHaTest : 고가용성                                            │
│  - KafkaConsumerFailoverTest : 컨슈머 페일오버                               │
├─────────────────────────────────────────────────────────────────────────────┤
│                         단위 테스트 (Mock 기반)                               │
│  - STTServiceTest : 서비스 로직                                              │
│  - STTControllerTest : 컨트롤러 계층                                         │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

## 2. 테스트별 상세 분석

### 2.1 분산락 테스트 (DistributedLockIntegrationTest)

#### 테스트 목적

다중 인스턴스 환경에서 **동일 STT 작업의 중복 처리를 방지**하기 위한 Redis 기반 분산락의 정확성을 검증합니다.

#### 핵심 시나리오

| 시나리오 | 비즈니스 의미 | 검증 방법 |
|---------|-------------|----------|
| 동시 락 획득 (10 스레드) | 같은 STT를 여러 서버가 동시에 처리하려 할 때 1개만 성공 | `CountDownLatch` + `AtomicInteger` |
| TTL 만료 후 재획득 | 서버 크래시 시 데드락 방지 | `Awaitility`로 TTL 만료 대기 |
| 원자적 획득 (100 스레드) | Race condition 없이 정확히 1개만 성공 | 대규모 동시 요청 |

#### 성능 의미

```
┌─────────────────────────────────────────────────────────────────┐
│ 시나리오: 3개 서버가 동시에 STT ID 123 처리 시도                   │
├─────────────────────────────────────────────────────────────────┤
│ Server A ──▶ acquireLock("stt:lock:123") ✅ 성공                │
│ Server B ──▶ acquireLock("stt:lock:123") ❌ 실패 → 스킵          │
│ Server C ──▶ acquireLock("stt:lock:123") ❌ 실패 → 스킵          │
├─────────────────────────────────────────────────────────────────┤
│ 결과: 정확히 1번만 처리됨 (중복 API 호출 방지, 리소스 절약)         │
└─────────────────────────────────────────────────────────────────┘
```

---

### 2.2 Kafka 통합 테스트 (SttKafkaIntegrationTest)

#### 테스트 목적

**비동기 이벤트 기반 아키텍처**에서 메시지의 신뢰성 있는 전달과 순서 보장을 검증합니다.

#### 핵심 시나리오

| 시나리오 | 비즈니스 의미 | 검증 방법 |
|---------|-------------|----------|
| 메시지 순서 보장 | 같은 STT의 이벤트가 순서대로 처리됨 | 동일 키 → 동일 파티션 |
| 수동 커밋 | 처리 완료 전 서버 죽으면 재처리 | 커밋 전 Consumer 종료 |
| 1000개 메시지 처리량 | 대량 요청 시 시스템 안정성 | 처리량 측정 |
| DLT 이동 | 재시도 실패 시 실패 메시지 보존 | DLT 토픽 확인 |

#### RetryableTopic 동작 흐름

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                    @RetryableTopic(attempts = 1000)                         │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  stt-processing-topic                                                       │
│        │                                                                    │
│        ▼                                                                    │
│  ┌──────────────┐                                                          │
│  │  Consumer    │──▶ SttNotCompletedException (STT 미완료)                   │
│  └──────────────┘                                                          │
│        │                                                                    │
│        ▼ 2초 후 재시도                                                       │
│  ┌──────────────────────────────────────────────────────────────┐          │
│  │  stt-processing-topic-retry-0  (1차 재시도)                   │          │
│  │  stt-processing-topic-retry-1  (2차 재시도)                   │          │
│  │  ...                                                         │          │
│  │  stt-processing-topic-retry-999 (1000차 재시도)               │          │
│  └──────────────────────────────────────────────────────────────┘          │
│        │                                                                    │
│        ▼ 1000회 초과 시                                                      │
│  ┌──────────────────────────────────────────────────────────────┐          │
│  │  stt-processing-topic-dlt (Dead Letter Topic)                │          │
│  │  → 실패 메시지 보존, 모니터링/수동 처리 대상                      │          │
│  └──────────────────────────────────────────────────────────────┘          │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

### 2.3 E2E 통합 테스트 (SttE2EIntegrationTest)

#### 테스트 목적

**전체 STT 처리 파이프라인**이 올바르게 상태 전이하고, 외부 API(Daglo)와의 통합이 정상 동작하는지 검증합니다.

#### 상태 전이 다이어그램

```
                    ┌───────────────────────────────────────────────────────┐
                    │                 STT 상태 머신                          │
                    └───────────────────────────────────────────────────────┘
                                            │
                                            ▼
┌──────────┐    finish=true    ┌──────────┐    인코딩완료    ┌──────────┐
│ RECORDING │────────────────▶│ ENCODING │───────────────▶│ ENCODED  │
└──────────┘                   └──────────┘                 └──────────┘
     │                                                           │
     │ Heartbeat 만료                                             │ 사용자 변환 요청
     │ (비정상 종료)                                               │
     ▼                                                           ▼
┌──────────┐                                              ┌──────────────┐
│ ENCODING │◀─────────────────────────────────────────────│ PROCESSING   │
└──────────┘                                              │ (rid 발급)    │
                                                          └──────────────┘
                                                                 │
                                                                 │ STT 완료
                                                                 ▼
                                                          ┌──────────────┐
                                                          │ SUMMARIZING  │
                                                          │ (summaryRid) │
                                                          └──────────────┘
                                                                 │
                                                                 │ 요약 완료
                                                                 ▼
                                                          ┌──────────────┐
                                                          │  COMPLETED   │
                                                          │ (DB 저장)     │
                                                          └──────────────┘
```

#### WireMock 스텁 시나리오

```java
// 진행중 → 완료 시나리오
stubFor(get("/stt/v1/async/transcripts/{rid}")
    .inScenario("STT Progress")
    .whenScenarioStateIs("Started")
    .willReturn(aResponse()
        .withBody("{\"status\": \"processing\", \"progress\": 50}"))
    .willSetStateTo("InProgress"));

stubFor(get("/stt/v1/async/transcripts/{rid}")
    .inScenario("STT Progress")
    .whenScenarioStateIs("InProgress")
    .willReturn(aResponse()
        .withBody("{\"status\": \"transcribed\", \"progress\": 100}")));
```

---

### 2.4 클러스터 HA 테스트 (KafkaClusterHaTest)

#### 테스트 목적

**장애 상황에서의 시스템 복원력**을 검증합니다. 브로커 재시작, 네트워크 지연, Redis 장애 시 시스템이 graceful하게 동작하는지 확인합니다.

#### 핵심 시나리오

| 시나리오 | 장애 유형 | 기대 동작 |
|---------|----------|----------|
| 컨테이너 재시작 | Kafka 브로커 다운 | 메시지 유지, 복구 후 소비 |
| Consumer 리밸런싱 | 컨슈머 추가/제거 | 파티션 재할당 |
| Redis 연결 끊김 | 캐시 서버 장애 | 예외 처리, fallback |
| 높은 동시성 | 대규모 요청 | Kafka+Redis 동시 사용 안정성 |

#### 고가용성 검증 의미

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                         장애 시나리오 및 복구                                 │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  [정상 상태]                                                                 │
│  Producer ──▶ Kafka Broker ──▶ Consumer                                    │
│                                                                             │
│  [브로커 장애 발생]                                                          │
│  Producer ──▶ ❌ Kafka Broker (다운)                                        │
│       │                                                                     │
│       └──▶ 재시도 (retries=3, backoff=1s)                                   │
│                                                                             │
│  [브로커 복구]                                                               │
│  Producer ──▶ ✅ Kafka Broker ──▶ Consumer                                  │
│                                                                             │
│  검증 포인트:                                                                │
│  - 메시지 유실 없음                                                          │
│  - 순서 보장 (같은 파티션 내)                                                 │
│  - Producer/Consumer 자동 재연결                                             │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

### 2.5 컨슈머 페일오버 테스트 (KafkaConsumerFailoverTest)

#### 테스트 목적

**다중 인스턴스 환경에서 컨슈머 장애 시 파티션 재할당 및 메시지 연속성**을 검증합니다. 운영 환경에서 서버 인스턴스가 죽거나 배포될 때 메시지가 유실되지 않고 처리되는지 확인합니다.

#### 핵심 시나리오

| 시나리오 | 장애 유형 | 기대 동작 |
|---------|----------|----------|
| 다중 컨슈머 파티션 분산 | 정상 상태 | 3개 파티션이 3개 컨슈머에 균등 분배 |
| 단일 컨슈머 죽음 | 인스턴스 다운 | 남은 컨슈머가 모든 파티션 인수 |
| 모든 컨슈머 죽음 → 복구 | 전체 장애 후 복구 | 커밋된 오프셋부터 재개 |
| 순차적 장애 | 연속 페일오버 | Consumer1→2→3 순차 인수, 메시지 유실 없음 |

#### 운영 시나리오 검증

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                       다중 인스턴스 페일오버 시나리오                          │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  [정상 상태 - 3개 인스턴스]                                                   │
│  ┌─────────┐  ┌─────────┐  ┌─────────┐                                      │
│  │Server A │  │Server B │  │Server C │                                      │
│  │ P0      │  │ P1      │  │ P2      │  ← 파티션 분산                        │
│  └─────────┘  └─────────┘  └─────────┘                                      │
│                                                                             │
│  [Server B 죽음 → 파티션 재할당]                                              │
│  ┌─────────┐  ┌─────────┐  ┌─────────┐                                      │
│  │Server A │  │   ❌    │  │Server C │                                      │
│  │ P0, P1  │  │ (down)  │  │ P2      │  ← P1이 Server A로 재할당             │
│  └─────────┘  └─────────┘  └─────────┘                                      │
│                                                                             │
│  [모든 서버 죽음 → 메시지 대기]                                                │
│  ┌─────────┐  ┌─────────┐  ┌─────────┐                                      │
│  │   ❌    │  │   ❌    │  │   ❌    │                                      │
│  │ (down)  │  │ (down)  │  │ (down)  │  ← Kafka에 메시지 보관                │
│  └─────────┘  └─────────┘  └─────────┘                                      │
│          ↓                                                                  │
│  [서버 복구 → 커밋된 오프셋부터 재개]                                          │
│  ┌─────────┐                                                                │
│  │Server D │  ← 새 서버가 같은 그룹 ID로 조인                                  │
│  │P0,P1,P2 │  ← 커밋된 오프셋부터 처리 재개 (at-least-once)                   │
│  └─────────┘                                                                │
│                                                                             │
│  핵심 검증:                                                                  │
│  - 다운타임 중 발행된 메시지 유실 없음                                         │
│  - 커밋된 오프셋 기반 재개                                                    │
│  - 중복 처리 허용 (at-least-once), 유실 불허                                  │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

#### 테스트 상세

| 테스트 메서드 | 검증 내용 | 비즈니스 의미 |
|-------------|----------|-------------|
| `multipleConsumers_PartitionsDistributed` | 3개 파티션이 3개 컨슈머에 분산 | 로드밸런싱 정상 동작 |
| `consumerDeath_PartitionReassignment` | 남은 컨슈머가 모든 파티션 처리 | 장애 시 서비스 연속성 |
| `allConsumersDeath_Recovery` | 커밋된 오프셋부터 재개 | 전체 장애 후 복구 보장 |
| `consumerGroupMonitoring` | AdminClient로 상태 모니터링 | 운영 모니터링 가능 |
| `sequentialConsumerFailure` | 연속 페일오버 시 메시지 무손실 | 롤링 배포 안전성 |

---

## 3. 사용 기술 딥다이브

### 3.1 Testcontainers

#### 개념

Testcontainers는 **Docker 컨테이너를 테스트 코드에서 프로그래밍 방식으로 관리**하는 Java 라이브러리입니다. 실제 인프라(Redis, Kafka, MySQL 등)를 테스트에 사용할 수 있습니다.

#### 동작 원리

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                        Testcontainers 라이프사이클                           │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  1. @Container 어노테이션 감지                                               │
│     │                                                                       │
│     ▼                                                                       │
│  2. Docker 이미지 풀 (없으면)                                                │
│     - redis:7-alpine                                                        │
│     - confluentinc/cp-kafka:7.6.0                                          │
│     │                                                                       │
│     ▼                                                                       │
│  3. 컨테이너 시작 (랜덤 포트 할당)                                            │
│     - Redis: localhost:49152                                               │
│     - Kafka: localhost:49153                                               │
│     │                                                                       │
│     ▼                                                                       │
│  4. @DynamicPropertySource로 Spring 설정 주입                               │
│     - spring.data.redis.port=49152                                         │
│     - spring.kafka.bootstrap-servers=localhost:49153                       │
│     │                                                                       │
│     ▼                                                                       │
│  5. 테스트 실행                                                              │
│     │                                                                       │
│     ▼                                                                       │
│  6. 테스트 종료 시 컨테이너 자동 정리                                          │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

#### 왜 Testcontainers인가?

| 비교 항목 | Embedded/Mock | Testcontainers |
|----------|--------------|----------------|
| 실제 동작 | ❌ 근사치 | ✅ 실제 동작 |
| 버전 호환성 검증 | ❌ 불가 | ✅ 실제 버전 테스트 |
| 프로덕션 유사성 | 낮음 | 높음 |
| 설정 복잡도 | 낮음 | 중간 |
| 테스트 속도 | 빠름 | 느림 (컨테이너 시작) |

**선택 이유**: STT 시스템은 Redis 분산락과 Kafka 이벤트에 크게 의존하므로, Mock으로는 발견하기 어려운 **실제 분산 시스템 문제**를 검증해야 합니다.

---

### 3.2 WireMock

#### 개념

WireMock은 **HTTP 기반 API를 모킹**하는 도구입니다. 외부 API(Daglo STT/NLP)의 응답을 시뮬레이션하여 테스트 격리를 달성합니다.

#### 동작 원리

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                          WireMock 동작 방식                                  │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  ┌─────────────┐          ┌─────────────┐          ┌─────────────┐         │
│  │ Application │──────────│  WireMock   │──────────│   스텁 정의   │         │
│  │ (WebClient) │  HTTP    │   Server    │  매칭    │  (JSON 응답)  │         │
│  └─────────────┘          └─────────────┘          └─────────────┘         │
│                                                                             │
│  요청 매칭 규칙:                                                             │
│  - URL 패턴: /stt/v1/async/transcripts/{rid}                               │
│  - HTTP 메서드: GET, POST                                                   │
│  - 요청 바디: JSON 패턴 매칭                                                  │
│                                                                             │
│  고급 기능:                                                                  │
│  - 시나리오 기반 상태 머신 (처리중 → 완료)                                     │
│  - 지연 응답 (네트워크 지연 시뮬레이션)                                        │
│  - 오류 응답 (4xx, 5xx)                                                     │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

#### 시나리오 기반 스텁 예시

```java
// 1차 요청: 처리중
stubFor(get(urlMatching("/stt/v1/async/transcripts/.*"))
    .inScenario("STT")
    .whenScenarioStateIs(Scenario.STARTED)
    .willReturn(aResponse()
        .withStatus(200)
        .withBody("{\"status\":\"processing\",\"progress\":50}"))
    .willSetStateTo("COMPLETED"));

// 2차 요청: 완료
stubFor(get(urlMatching("/stt/v1/async/transcripts/.*"))
    .inScenario("STT")
    .whenScenarioStateIs("COMPLETED")
    .willReturn(aResponse()
        .withStatus(200)
        .withBody("{\"status\":\"transcribed\",\"progress\":100}")));
```

---

### 3.3 Awaitility

#### 개념

Awaitility는 **비동기 작업의 완료를 대기**하는 DSL입니다. 폴링 기반으로 조건이 만족될 때까지 대기합니다.

#### 동작 원리

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                        Awaitility 폴링 메커니즘                              │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  await()                                                                    │
│    .atMost(10, TimeUnit.SECONDS)     // 최대 대기 시간                       │
│    .pollInterval(100, TimeUnit.MILLISECONDS)  // 폴링 간격                   │
│    .until(() -> condition);          // 조건 확인                            │
│                                                                             │
│  ┌──────┐                                                                   │
│  │ t=0  │ ──▶ condition 확인 ──▶ false                                      │
│  └──────┘                                                                   │
│      │                                                                      │
│      ▼ 100ms 대기                                                           │
│  ┌──────┐                                                                   │
│  │t=100 │ ──▶ condition 확인 ──▶ false                                      │
│  └──────┘                                                                   │
│      │                                                                      │
│      ▼ 100ms 대기                                                           │
│  ┌──────┐                                                                   │
│  │t=200 │ ──▶ condition 확인 ──▶ true ✅ 성공                               │
│  └──────┘                                                                   │
│                                                                             │
│  10초 초과 시: ConditionTimeoutException 발생                                │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

#### 사용 예시

```java
// TTL 만료 대기
await().atMost(3, TimeUnit.SECONDS)
    .pollInterval(100, TimeUnit.MILLISECONDS)
    .until(() -> !Boolean.TRUE.equals(redisTemplate.hasKey(lockKey)));

// Kafka 메시지 수신 대기
await().atMost(10, TimeUnit.SECONDS)
    .untilAsserted(() -> {
        ConsumerRecords<String, String> records = consumer.poll(Duration.ofMillis(500));
        assertThat(records.count()).isGreaterThan(0);
    });
```

---

### 3.4 k6

#### 개념

k6은 **JavaScript로 작성하는 성능 테스트 도구**입니다. HTTP, WebSocket, gRPC 등 다양한 프로토콜을 지원합니다.

#### 동작 원리

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                           k6 실행 모델                                       │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  ┌──────────────────────────────────────────────────────────────────┐      │
│  │                        k6 Engine                                 │      │
│  │  ┌──────┐  ┌──────┐  ┌──────┐  ┌──────┐  ┌──────┐             │      │
│  │  │ VU 1 │  │ VU 2 │  │ VU 3 │  │ ... │  │ VU N │             │      │
│  │  └──────┘  └──────┘  └──────┘  └──────┘  └──────┘             │      │
│  │      │          │          │          │          │               │      │
│  │      └──────────┴──────────┴──────────┴──────────┘               │      │
│  │                          │                                        │      │
│  │                          ▼                                        │      │
│  │                   default function()                              │      │
│  │                   (각 VU가 반복 실행)                               │      │
│  └──────────────────────────────────────────────────────────────────┘      │
│                              │                                              │
│                              ▼                                              │
│  ┌──────────────────────────────────────────────────────────────────┐      │
│  │                     Target Server                                │      │
│  │                   (localhost:8080)                               │      │
│  └──────────────────────────────────────────────────────────────────┘      │
│                                                                             │
│  VU (Virtual User): 가상 사용자, 동시 요청 생성 단위                           │
│  Iteration: VU가 default function()을 1회 완료하는 것                        │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

#### 시나리오 유형

```javascript
export const options = {
    scenarios: {
        // Smoke: 기본 기능 확인
        smoke: {
            executor: 'shared-iterations',
            vus: 1,
            iterations: 3,
        },
        // Load: 예상 부하 시뮬레이션
        load: {
            executor: 'ramping-vus',
            stages: [
                { duration: '30s', target: 10 },   // Ramp-up
                { duration: '2m', target: 10 },    // Steady
                { duration: '30s', target: 0 },    // Ramp-down
            ],
        },
        // Stress: 한계 테스트
        stress: {
            executor: 'ramping-vus',
            stages: [
                { duration: '30s', target: 50 },
                { duration: '1m', target: 100 },
            ],
        },
    },
};
```

---

## 4. 성능 지표 및 임계값

### 4.1 Testcontainers 테스트 성능 기준

| 테스트 | 실행 시간 기준 | 메모리 기준 | 비고 |
|--------|-------------|-----------|------|
| 분산락 단일 테스트 | < 5초 | < 50MB | Redis 연결 포함 |
| 분산락 동시성 테스트 | < 10초 | < 100MB | 100 스레드 |
| Kafka 1000 메시지 | < 30초 | < 200MB | 발행+소비 |
| E2E 전체 플로우 | < 30초 | < 150MB | 10개 시나리오 |
| HA 테스트 전체 | < 60초 | < 300MB | 복구 시간 포함 |

### 4.2 k6 성능 임계값

| 메트릭 | 임계값 | 의미 |
|--------|--------|------|
| `stt_start_duration` p(95) | < 1000ms | 녹음 시작 API 응답 시간 |
| `stt_chunk_duration` p(95) | < 500ms | 청크 업로드 API 응답 시간 |
| `stt_status_duration` p(95) | < 300ms | 상태 조회 API 응답 시간 |
| `http_req_failed` | < 5% | HTTP 오류율 |
| `ws_connect_duration` p(95) | < 3000ms | WebSocket 연결 시간 |
| `ws_message_latency` p(95) | < 500ms | WebSocket 메시지 레이턴시 |

### 4.3 분산락 성능 특성

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                      분산락 성능 분석                                        │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  락 획득 시간 분포 (Redis SETNX):                                            │
│                                                                             │
│  ┌────────────────────────────────────────────────────┐                    │
│  │ p50: ~1ms   │ p95: ~5ms   │ p99: ~10ms            │                    │
│  └────────────────────────────────────────────────────┘                    │
│                                                                             │
│  동시 요청 시 성공률:                                                        │
│  - 10 스레드 동시: 1/10 = 10% 성공 (예상대로)                                │
│  - 100 스레드 동시: 1/100 = 1% 성공 (예상대로)                               │
│                                                                             │
│  TTL 설정 가이드:                                                            │
│  - 작업 예상 시간 + 버퍼 (일반적으로 2-3배)                                   │
│  - 너무 짧으면: 작업 중 락 만료 → 중복 처리                                   │
│  - 너무 길면: 장애 시 복구 지연                                              │
│  - 현재 설정: 5초 (인코딩/처리 작업용)                                        │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

## 5. 커버하지 못한 시나리오

### 5.1 커버되지 않은 시나리오 목록

| 카테고리 | 시나리오 | 커버하지 못한 이유 | 위험도 |
|---------|---------|------------------|--------|
| **네트워크** | 실제 네트워크 파티션 | Docker 네트워크 격리 한계 | 중 |
| **장애** | 실제 브로커 크래시 | 테스트 시간 제약 | 중 |
| **데이터** | 실제 오디오 파일 STT 변환 | 외부 API 의존 (비용/시간) | 낮음 |
| **부하** | 장시간 Soak 테스트 | CI/CD 시간 제약 | 중 |
| **보안** | 인증/권한 통합 테스트 | 별도 보안 테스트 영역 | 낮음 |
| **인프라** | 멀티 브로커 클러스터 | 단일 브로커 Testcontainers | 중 |

### 5.2 상세 분석

#### 네트워크 파티션 (Split-Brain)

```
커버되지 않은 시나리오:
┌──────────┐         ┌──────────┐
│ Server A │ ──✗──── │ Server B │   (네트워크 단절)
└──────────┘         └──────────┘
     │                    │
     ▼                    ▼
┌──────────┐         ┌──────────┐
│ Redis A  │         │ Redis B  │   (Split-Brain)
└──────────┘         └──────────┘

이유: Testcontainers는 단일 Redis 인스턴스만 지원
권장: Chaos Engineering 도구 (Chaos Monkey, Litmus) 사용
```

#### 실제 Daglo API 통합

```
커버되지 않은 시나리오:
- 실제 오디오 파일 업로드 → STT 변환 → 결과 수신

이유:
- 외부 API 비용 발생
- 테스트 실행 시간 증가 (분 단위)
- 외부 서비스 가용성에 의존

권장:
- Contract Testing (Pact) 도입
- 주기적인 통합 환경 E2E 테스트 (1일 1회)
```

#### 장시간 안정성 (Soak Test)

```
커버되지 않은 시나리오:
- 24시간 연속 부하 → 메모리 누수, 커넥션 풀 고갈 확인

이유:
- CI/CD 파이프라인 시간 제약 (일반적으로 30분 이내)
- 리소스 비용

권장:
- 별도 Soak 테스트 파이프라인 구성 (야간 실행)
- Prometheus + Grafana로 장기 메트릭 모니터링
```

---

## 6. 추천 테스트 전략

### 6.1 테스트 피라미드

```
                    ┌─────────────┐
                    │   E2E/k6    │  ← 적게, 핵심 시나리오만
                    │  (느리고    │
                    │   비쌈)     │
                    └─────────────┘
               ┌─────────────────────┐
               │   통합 테스트        │  ← Testcontainers
               │   (Testcontainers)  │
               │                     │
               └─────────────────────┘
          ┌───────────────────────────────┐
          │         단위 테스트            │  ← 가장 많이
          │         (Mockito)             │
          │                               │
          └───────────────────────────────┘
```

### 6.2 CI/CD 파이프라인 권장 구성

```yaml
# .github/workflows/test.yml (예시)
stages:
  - name: Unit Tests
    command: ./gradlew test --tests "*Test" --exclude "*IntegrationTest"
    timeout: 10m

  - name: Integration Tests (Testcontainers)
    command: ./gradlew test --tests "*IntegrationTest"
    timeout: 15m
    services:
      - docker:dind

  - name: k6 Smoke Test
    command: k6 run --tag test_type=smoke k6/stt-load-test.js
    timeout: 5m
    only: [main, develop]

  - name: k6 Load Test (Nightly)
    command: k6 run k6/stt-load-test.js
    schedule: "0 2 * * *"  # 매일 새벽 2시
    timeout: 30m
```

### 6.3 추천 개선 사항

#### 단기 (1-2주)

| 항목 | 설명 | 우선순위 |
|------|------|---------|
| Contract Testing | Pact로 Daglo API 계약 테스트 | 높음 |
| 테스트 데이터 팩토리 | 테스트 데이터 생성 유틸리티 확장 | 중 |
| 테스트 리포트 개선 | Allure Report 도입 | 낮음 |

#### 중기 (1-2개월)

| 항목 | 설명 | 우선순위 |
|------|------|---------|
| Chaos Engineering | Redis/Kafka 장애 주입 테스트 | 중 |
| 멀티 브로커 테스트 | Kafka 클러스터 환경 테스트 | 중 |
| 성능 벤치마크 자동화 | k6 결과 대시보드 구축 | 낮음 |

#### 장기 (3개월+)

| 항목 | 설명 | 우선순위 |
|------|------|---------|
| Observability | 테스트 메트릭 수집/분석 | 중 |
| 보안 테스트 | OWASP ZAP 통합 | 중 |
| 스테이징 E2E | 실제 환경 통합 테스트 | 낮음 |

---

### 6.4 테스트 커버리지 목표

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                        STT 패키지 커버리지 목표                               │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  컴포넌트              현재        목표         비고                         │
│  ────────────────────────────────────────────────────────────────────────  │
│  STTService            85%        90%         단위 테스트 강화               │
│  SttJobProcessor       70%        85%         통합 테스트 보완               │
│  SttTaskConsumer       60%        80%         Kafka 리스너 테스트            │
│  DistributedLockMgr    95%        95%         현재 충분                      │
│  DagloSttProvider      40%        70%         WireMock 시나리오 확장         │
│  SttCacheService       90%        90%         현재 충분                      │
│  ────────────────────────────────────────────────────────────────────────  │
│  전체                   75%        85%                                       │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

## 부록: 테스트 실행 명령 모음

```bash
# 전체 STT 통합 테스트
./gradlew test --tests "com.codehows.daehobe.stt.integration.*"

# 분산락 테스트만
./gradlew test --tests "DistributedLockIntegrationTest"

# Kafka 테스트만
./gradlew test --tests "SttKafkaIntegrationTest"

# E2E 테스트만
./gradlew test --tests "SttE2EIntegrationTest"

# HA 테스트만
./gradlew test --tests "KafkaClusterHaTest"

# 컨슈머 페일오버 테스트만
./gradlew test --tests "KafkaConsumerFailoverTest"

# k6 Smoke 테스트
k6 run --tag test_type=smoke k6/stt-load-test.js

# k6 Load 테스트
k6 run -e BASE_URL=http://localhost:8080 k6/stt-load-test.js

# k6 WebSocket 테스트
k6 run -e WS_URL=ws://localhost:8080/ws k6/stt-websocket-test.js

# k6 결과 JSON 출력
k6 run --out json=results.json k6/stt-load-test.js

# 테스트 커버리지 리포트
./gradlew test jacocoTestReport
```
